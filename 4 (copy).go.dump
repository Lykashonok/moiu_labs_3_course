package main

import (
	"fmt"
	"math"

	"gonum.org/v1/gonum/mat"
)

func vecMulMat(vec *mat.VecDense, matrix *mat.Dense) *mat.VecDense {
	vectorPre := mat.NewDense(vec.Len(), vec.Len(), nil)
	vectorPre.SetRow(0, RawVector(vec))
	vectorPre.Mul(vectorPre, matrix)
	// Start dual plan - vector y
	return mat.VecDenseCopyOf(vectorPre.ColView(0))
}

func doubleSimplexMethod(scalesVector *VecSign, conditionsMatrix *mat.Dense, freeVector *mat.VecDense, variableSigns []Sign, baselineIndexes *mat.VecDense) {
	conditionsNumber, varNumber := conditionsMatrix.Dims()
	// dualScalesVector := &VecSign{mat.VecDenseCopyOf(scalesVector.vec), MIN}
	// if scalesVector.sign == MIN {
	// 	dualScalesVector.sign = MAX
	// }

	// variableKinds, dualVariableKinds := make([]int8, conditionsNumber), make([]int8, conditionsNumber) // -1 - neither, 0 - bad, 1 - good
	// dualConditionsMatrix := mat.NewDense(conditionsNumber, conditionsNumber, nil)
	// dualVariableSigns := make([]Sign, conditionsNumber)
	// dualFreeVector := mat.NewVecDense(varNumber, nil)
	nonBaseLineIndexes, j := mat.NewVecDense(varNumber-conditionsNumber, nil), 0
	for i := 0; i < varNumber; i++ {
		if !Find(RawVector(baselineIndexes), float64(i)) {
			nonBaseLineIndexes.SetVec(j, float64(i))
			j++
		}
	}

	// for i := 0; i < conditionsNumber; i++ {
	// 	for j := 0; j < conditionsNumber; j++ {
	// 		dualConditionsMatrix.Set(j, i, conditionsMatrix.At(i, j))
	// 	}

	// 	if variableSigns[i] == RATIONAL {
	// 		// Neither
	// 		dualVariableKinds[i] = -1
	// 	} else if variableSigns[i] == LESSEQUAL && dualScalesVector.sign == MAX ||
	// 		variableSigns[i] == MOREEQUAL && dualScalesVector.sign == MIN {
	// 		// GOOD
	// 		dualVariableKinds[i] = 1
	// 	} else {
	// 		// BAD
	// 		dualVariableKinds[i] = 0
	// 	}

	// 	if variableSigns[i] == RATIONAL {
	// 		// Neither
	// 		variableKinds[i] = -1
	// 	} else if variableSigns[i] == LESSEQUAL && scalesVector.sign == MAX ||
	// 		variableSigns[i] == MOREEQUAL && scalesVector.sign == MIN {
	// 		// GOOD
	// 		variableKinds[i] = 1
	// 	} else {
	// 		// BAD
	// 		variableKinds[i] = 0
	// 	}

	// 	if variableKinds[i] == -1 {
	// 		dualVariableSigns[i] = EQUAL
	// 	} else if variableKinds[i] == 1 && dualScalesVector.sign == MAX ||
	// 		variableKinds[i] == 0 && dualScalesVector.sign == MIN {
	// 		dualVariableSigns[i] = LESSEQUAL
	// 	} else if variableKinds[i] == 1 && dualScalesVector.sign == MIN ||
	// 		variableKinds[i] == 0 && dualScalesVector.sign == MAX {
	// 		dualVariableSigns[i] = MOREEQUAL
	// 	}

	// 	dualFreeVector.SetVec(i, scalesVector.vec.AtVec(i))
	// }

	// BaselineVector and matrix
	baselineMatrix := mat.NewDense(conditionsNumber, conditionsNumber, nil)
	baselineVector := mat.NewVecDense(conditionsNumber, nil)
	for i := 0; i < conditionsNumber; i++ {
		baselineMatrix.SetCol(i, RawVector(conditionsMatrix.ColView(int(baselineIndexes.AtVec(i)))))
		baselineVector.SetVec(i, scalesVector.vec.AtVec(int(baselineIndexes.AtVec(i))))
	}
	baselineMatrixInv := mat.DenseCopyOf(baselineMatrix)
	baselineMatrixInv.Inverse(baselineMatrix)

	// Vector Kappa
	baselineKappa := mat.NewVecDense(conditionsNumber, nil)
	baselineKappa.MulVec(baselineMatrixInv, freeVector)

	kappa := mat.NewVecDense(varNumber, nil)
	for i := 0; i < conditionsNumber; i++ {
		kappa.SetVec(int(baselineIndexes.AtVec(i)), baselineKappa.AtVec(i))
	}

	// Checking if kappa is optimal case
	isOptimalCase, negativeIndex, negativeBaselineIndex := true, -1, 0
	negativeIndex += 1
	for i := 0; i < varNumber; i++ {
		if kappa.AtVec(i) < 0 {
			isOptimalCase = false
			negativeIndex = i
			for j := 0; j < conditionsNumber; j++ {
				if i == int(baselineIndexes.AtVec(j)) {
					negativeBaselineIndex = j
					break
				}
			}
			// break // if break is commented, last negative value will be observed, otherwise first
		}
	}
	if isOptimalCase {
		matPrint(kappa)
		panic("Optimal case!")
	}

	yVector := vecMulMat(baselineVector, baselineMatrixInv)
	yDeltaVector := mat.NewVecDense(conditionsNumber, RawVector(baselineMatrixInv.ColView(negativeBaselineIndex)))

	muList := make([]float64, varNumber-conditionsNumber)
	// for nonbaseline indexes
	for i := 0; i < varNumber-conditionsNumber; i++ {
		mu := mat.VecDenseCopyOf(yDeltaVector)
		muList[i] = mat.Dot(mu, conditionsMatrix.ColView(int(nonBaseLineIndexes.AtVec(i))))
	}

	isConsistent := false
	for i := 0; i < varNumber-conditionsNumber; i++ {
		if muList[i] < 0 {
			isConsistent = true
			break
		}
	}
	if !isConsistent {
		panic("Matrix is not consistent")
	}

	minSigma, minSigmaIndex := math.Inf(1), 0
	for i := 0; i < varNumber-conditionsNumber; i++ {
		currentNonBaselineIndex := int(nonBaseLineIndexes.AtVec(i))
		Cj := scalesVector.vec.AtVec(currentNonBaselineIndex)
		Aj := mat.Dot(conditionsMatrix.ColView(currentNonBaselineIndex), yVector)
		muj := muList[i]
		currentSigma := (Cj - Aj) / muj
		if currentSigma < minSigma {
			minSigma, minSigmaIndex = currentSigma, i
		}
	}

	// changing dual plan
	newBaselineIndexes := mat.VecDenseCopyOf(baselineIndexes)
	newBaselineIndexes.SetVec(negativeBaselineIndex, float64(minSigmaIndex))
	yDeltaVector.ScaleVec(minSigma, yDeltaVector)

	//  Updating y vector by adding y vector and scaled y delta vector
	yVector.AddVec(yVector, yDeltaVector)

	matPrint(yVector)
	matPrint(conditionsMatrix)
	// matPrint(dualConditionsMatrix)
	// matPrint(dualFreeVector)
	// fmt.Printf("%v\n", dualVariableSigns)
	// fmt.Printf("%v\n", variableKinds)
	fmt.Printf("%v\n", variableSigns)
	matPrint(baselineKappa)
}

func main() {
	scalesVector, conditionsMatrix, freeVector, variableSigns := readDoubleOptimizationProblem("input.txt", 5, 2)

	doubleSimplexMethod(scalesVector, conditionsMatrix, freeVector, variableSigns, mat.NewVecDense(2, []float64{3, 4}))

	fmt.Printf("%v %v %v %v\n", scalesVector, conditionsMatrix, freeVector, variableSigns)
}
